---
title: "R and ggplot2"
output: html_notebook
---

# R #

- Statistics-focused functional language
    - It looks more like JavaScript than Python
    - "Data scientists" will frequently swap between R and Python
- CRAN - open source repository for algorithms and libraries
    - The focal point for the statistics community in sharing code
    - Many advanced statistics algorithms are implemented in R
    - Good library support like *ggplot2* and *dplyr*
- RStudio, an IDE for *R*
    - Automatic integration with CRAN
    - Hyperlink help browser
    - Plot viewer and saved state integration
    - RMarkdown support, similar to Jupyter Notebooks
    - Shiny support, similar to Bokeh
- R + RStudio + CRAN is an example of a good software stack from an active, open-source community

---

# R Markdown

In *RStudio*, interactive documents or notebooks are done in Markdown.

Markdown is a simplified "markup" language (hence the name Markdown), for
writing all sorts of documents: e.g., Github READMEs. It has been adopted
for all sorts of formats, including writing web pages, documentation and code.

In RStudio, a "cell" (chunk) is free-form, as it is started and ended with three backticks:

\`\`\`{r}

`2 + 2`

\`\`\`

Then, that chunk can be executed in the IDE. Combined with *knitr*, you are able
to directly create HTML, PDF, and Word documents of your code, plots, and 
documentation: Just like this web page was created with RMarkdown.

---

# Data Frames and R

- Fundamental support for data frames
- It also has support for databases and SQL, as well
    - DBI interface for databases
        - SQLite, PostgreSQL, etc.
    - Load tables using queries directly as data frames
- I won't spend much time showing data frames in R, as they are more or less the same as Python (Pandas)
- Rather, I'll show *dplyr*, a library/grammar for manipulating tables (relational data)

---

# CSV to Data Frame

We can directly load our cars CSV as a data frame:

```{r}
# read the data as a data frame
t <- read.csv("mtcars.csv") # assignment in R is <-
t
```

---

# Data Frame Selection

Just to show you that it's similar to Pandas, with slightly different syntax:

```{r}
# select rows 5-10, columns mpg and cyl
t[5:10, c('mpg','cyl')]
```

---

# Selecting Columns with *dplyr*

First, we need to load dplyr.

```{r}
library(dplyr)
```

The way we select data with *dplyr* is through operator chaining, aka combinators, aka pipelines, aka data flow graphs.

`%>%` is the pipe operator, like `|` in Unix, and the operator is *select* for picking columns:

```{r}
t %>% 
  select(name, mpg, cyl)
```

If we were to write this in *bash*, it would look something like:

```bash
cat mtcars.csv | awk -F',' '{ print $2, $3 }'
```

By the way, a lot of what we have done with *Python* and *R* could be done with *bash* and *gnuplot*. That's just to say what is old isn't broken, and it can work just fine in many cases: <https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html>

---

# Filter (Where)

In *SQL*, the `WHERE` clause allows us to pick rows, and in *dplyr* it is the `filter` operator:

```{r}
# only show 3 gear cars, with their mpg and cyl
t %>% 
  filter(gear == 3) %>%
  select(name, mpg, cyl)
```

And we can combine them further:

```{r}
# same query as before, but only keep greater than 200 hp
t %>%
  filter(gear == 3) %>%
  filter(hp > 200) %>%
  select(name, mpg, cyl)
```

We can add `or` in a filter, too:

```{r}
# same query as before, 3 or 4 gears
t %>%
  filter(gear == 3 || gear == 4) %>%
  filter(hp > 200) %>%
  select(name, mpg, cyl)
```

---

# Note for Databases and *dplyr*

If *t* was a table that was in a database, it wouldn't be loaded into *R*'s memory.

In *dplyr*, a table from a database it is a "reference" to the table, and commands are only executed when *R* needs it.

This is "lazy evaluation," or "demand driven," a feature of both *Haskell*, *Spark*, *Dask*, and other languages. In the case of *dplyr*, when *t* is a database table, it execute queries only when you either display *t*, `collect()` it, or send it to a plot.

---

# Group By and Summaries

Grouping, like in *SQL*, is useful for summarizing functions, like min, max, or average:

```{r}
# what's the average hp for each cylinder size?
t %>%
  group_by(cyl) %>%
  summarize(mean_hp = mean(hp))
```

---

# Sorting

And sorting, or the *ORDER BY* in *SQL*, is done by `arrange`:

```{r}
# get cars with displacement < 100, and order by horsepower
t %>%
  filter(disp < 100) %>%
  select(name, hp, mpg) %>%
  arrange(hp)
```

---

# Plotting with ggplot2

Now that we know how to manipulate our data, we can plot it. We'll use *ggplot2*, where `gg` stands for the "grammar of graphics", first described by Leland Wilkinson and extended by Hadley Wickham. (Hadley wrote many of the other popular, useable libraries, like *dplyr*, and what comprises the *tidyverse* in *R*).

*ggplot2* seamlessly integrates with *dplyr* by piping the output directly into the *ggplot* function:

```{r}
library(ggplot2)

# plot 3 gear cars, mpg vs. hp
t %>%
  filter(gear == 3) %>%
  select(mpg, hp) %>%
  ggplot(.) + # start a plot, . is placeholder for the incoming data
  aes(x=mpg, y=hp) + # aes, is "aesthetics" -- how to map data to geometry
  geom_point() # the plot geometry
```

---

# Shiny

*Shiny* is like *Bokeh* for Python, as it is a way to generate interactive plots for R.

```{r}
library(shiny)

# the front end, the UI
ui <- basicPage(
  plotOutput("plot1",
    hover = "plot_hover",
    brush = "plot_brush"
  ),
  verbatimTextOutput("info")
)

# the back end, data processing
server <- function(input, output) {
  # the plot
  output$plot1 <- renderPlot({
  # this is our plot that we had before
  t %>%
    filter(gear == 3) %>%
    select(mpg, hp) %>%
    ggplot(.) + 
    aes(x=mpg, y=hp) + 
    geom_point() 
  })

  # generating the tooltip text based on the UI
  output$info <- renderText({
    xy_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("x=", round(e$x, 1), " y=", round(e$y, 1), "\n")
    }
    xy_range_str <- function(e) {
      if(is.null(e)) return("NULL\n")
      paste0("xmin=", round(e$xmin, 1), " xmax=", round(e$xmax, 1), 
             " ymin=", round(e$ymin, 1), " ymax=", round(e$ymax, 1))
    }

    paste0(
      "hover: ", xy_str(input$plot_hover),
      "brush: ", xy_range_str(input$plot_brush)
    )
  })
}

shinyApp(ui, server)
```

You probably won't see anything unless you are running the
interactive version of this document.

As you can see, we are able to get the same sort of
interactive graphics that is available through Bokeh in Python,
and D3 and the like in Javascript all in one ecosystem.

If I provided more controls, I could change it such that a
user within the application could change the filtering on
the data set, which is done at the SQL/file layer, while
the additional graphics transformations are done while computing.

Let's head back to the Jupyter notebook to finish up the slides.



